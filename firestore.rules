/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data is private and scoped to the authenticated
 * user who created it. The default security posture is deny-all, ensuring that no data is accessible unless explicitly
 * permitted by a rule.
 *
 * Data Structure: The data is organized hierarchically under a top-level `users` collection. Each user has a single
 * document, `/users/{userId}`, containing their profile information. All other user-specific data, such as their
 * locations, is stored in subcollections under their main document (e.g., `/users/{userId}/locations/{locationId}`).
 *
 * Key Security Decisions:
 * - User Enumeration is Disabled: Listing documents from the top-level `/users` collection is explicitly forbidden.
 *   This is a critical security measure to prevent malicious actors from harvesting a list of all application users.
 * - Strict Path-Based Ownership: A user's identity (`request.auth.uid`) is always checked against the `{userId}` wildcard
 *   in the document path. This ensures users can only ever access their own data tree.
 * - No Public Data: All collections and documents are considered private to their owner.
 *
 * Denormalization for Authorization: To ensure fast and secure authorization checks, the `UserLocation` documents stored
 * under `/users/{userId}/locations/{locationId}` contain a denormalized `userId` field. This allows rules to verify
 * ownership directly from the document's data on create and update operations, avoiding slow and costly `get()` calls
 * to the parent user profile document. This also enforces relational integrity, ensuring a location document cannot be
 * associated with the wrong user.
 *
 * Structural Segregation: The data model naturally segregates each user's private data into their own document tree.
 * This is an inherently secure pattern that simplifies rules for list operations, as queries on subcollections are
 * already scoped to a specific, authorized user.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for verifying document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations.
     * Verifies ownership AND ensures the document already exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // ----------------------------------------------------------------------
    // User Profile Rules
    // ----------------------------------------------------------------------

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow (create) A new user (auth.uid: 'user123') creating their own profile at `/users/user123`.
     * @allow (get) An existing user (auth.uid: 'user123') reading their own profile at `/users/user123`.
     * @allow (update) An existing user (auth.uid: 'user123') updating their own profile at `/users/user123`.
     * @deny (list) Any user attempting to list all documents in the `/users` collection.
     * @deny (get) User 'abc' attempting to read the profile of 'xyz' at `/users/xyz`.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      // ----------------------------------------------------------------------
      // User Locations Subcollection Rules
      // ----------------------------------------------------------------------

      /**
       * @description Manages access to a user's private list of locations.
       * @path /users/{userId}/locations/{locationId}
       * @allow (create) A signed-in user (auth.uid: 'user123') creating a new location under `/users/user123/locations/loc_abc`.
       * @allow (list) A signed-in user (auth.uid: 'user123') listing all locations under `/users/user123/locations`.
       * @deny (get) User 'abc' trying to read a specific location under `/users/xyz/locations/loc_def`.
       * @deny (update) User 'abc' trying to update a location under `/users/xyz/locations/loc_def`.
       * @principle Secures a user's private subcollection data based on ownership established in the path.
       */
      match /locations/{locationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}